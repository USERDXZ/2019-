## [HTTP协议知识点](https://github.com/semlinker/awesome-http#bs-%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89)

HTTP就是一个用文本格式描述报文头并用双换行分隔报文头和内容，在TCP基础上实现的请求-响应模式的双向通信协议。

```
                       权限                 路径
        ┌───────────────┴───────────────┐┌───┴────┐
  abc://username:password@example.com:123/path/data?key=value&key2=value2#fragid1
  └┬┘   └───────┬───────┘ └────┬────┘ └┬┘           └─────────┬─────────┘ └──┬──┘
  协议        用户信息         主机名    端口                  查询参数          片段
```

##### [HTTP1.0 和 HTTP1.1 的一些区别](https://www.cnblogs.com/wupeixuan/p/8642100.html)
HTTP协议的第三个版本是HTTP/1.1，是目前使用最广泛的协议版本。HTTP/1.1是目前主流的HTTP协议版本，相对于HTTP/1.0新增了以下内容：

1. 默认为长连接

   HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection：keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。

2. 提供了范围请求功能(宽带优化)

   HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。这是支持文件断点续传的基础。

3. 提供了虚拟主机的功能(HOST域)

   在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，**且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。**

4. 多了一些缓存处理字段

   HTTP/1.1在1.0的基础上加入了一些cache的新特性，引入了实体标签，一般被称为e-tags，新增更为强大的Cache-Control头。

5. 错误通知的管理

   在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。

##### HTTPS 与 HTTP 的一些区别

1. HTTPS 协议需要到 CA 申请证书，一般免费证书很少，需要交费。
2. **HTTP 协议**运行在 TCP 之上，所有传输的内容都是**明文**，**HTTPS** 运行在 SSL/TLS 之上，SSL/TLS 运行在 TCP 之上，所有**传输的内容都经过加密**的。
3. HTTP 和 HTTPS 使用的是**完全不同的连接方式，用的端口也不一样**，前者是 80，后者是 443。
4. HTTPS 可以有效的**防止运营商劫持**，解决了防劫持的一个大问题。



#### [从输入URL到页面加载发生了什么](https://www.cnblogs.com/xiaohuochai/p/9193083.html)

1. DNS解析
2. TCP连接
3. 发送HTTP请求
4. 服务器处理请求并返回HTTP报文
5. 浏览器解析渲染页面
6. 连接结束

浏览器中输入一个URL发生什么，用到哪些协议？
浏览器中输入URL，首先浏览器要将URL解析为IP地址，解析域名就要用到DNS协议，首先主机会**查询DNS的缓存**，如果没有就给**本地DNS**发送查询请求。DNS查询分为两种方式，一种是递归查询，一种是迭代查询。如果是迭代查询，本地的DNS服务器，向根域名服务器发送查询请求，根域名服务器告知该域名的一级域名服务器，然后本地服务器给该一级域名服务器发送查询请求，然后依次类推直到查询到该域名的IP地址。DNS服务器是基于UDP的，因此会用到UDP协议。
得到IP地址后，浏览器就要与服务器建立一个http连接。因此要用到http协议，http协议报文格式上面已经提到。http生成一个get请求报文，将该报文传给TCP层处理。**如果采用https还会先对http数据进行加密**。TCP层如果有需要先将HTTP数据包分片，分片依据路径MTU和MSS。TCP的数据包然后会发送给IP层，用到IP协议。IP层通过路由选路，一跳一跳发送到目的地址。当然在**一个网段内的寻址是通过以太网协议实现**(也可以是其他物理层协议，比如PPP，SLIP)，以太网协议需要知道目的IP地址的物理地址，又需要ARP协议。

**MTU：** **Maximum Transmit Unit**，最大传输单元，即**物理接口（数据链路层）提供给其上层最大一次传输数据的大小**，比如IP层、MPLS层等等，因为目前应用最多的接口是以太网，所以谈谈以太网口的MTU，假定其上层协议是IP，缺省MTU=1500，意思是：整个IP包最大从这个接口发送出去的是1500个字节。可以通过配置修改成更大或更小的值，只要在系统的边界值以内即可，但是切记要在链路的两端都要修改，而且要大小一样，如果不一样，会造成大侧的数据被小侧丢弃！

**MSS：Maximum Segment Size** ，**最大TCP分段大小**，不包含TCP头和 option，只包含TCP Payload ，TCP用来限制自己每次发送的最大分段尺寸。（1460）



#####  get/post 区别
区别一：
get重点在从服务器上获取资源，post重点在向服务器发送数据；
区别二：
get传输数据是通过URL请求，以field（字段）= value的形式，置于URL后，并用"?"连接，多个请求数据间用"&"连接，如http://127.0.0.1/Test/login.action?name=admin&password=admin，这个过程用户是可见的；
post传输数据通过Http的post机制，**将字段与对应值封存在请求实体中发送给服务器**，这个过程对用户是不可见的；
区别三：
Get传输的**数据量小**，因为受URL长度限制，但效率较高；
Post可以传输大量数据，所以上传文件时只能用Post方式；
区别四：
**get是不安全的，因为URL是可见的，可能会泄露私密信息，如密码等；**
post较get安全性较高；



#### [FTP协议](https://blog.csdn.net/zhubao124/article/details/81662775) 文件传输协议

相比其他协议，如 HTTP 协议，FTP 协议要复杂一些。	与一般的 C/S 应用不同点在于一般的C/S 应用程序一般只会建立一个 Socket 连接，这个连接同时处理服务器端和客户端的连接命令和数据传输。而FTP协议中将命令与数据分开传送的方法提高了效率。

FTP 使用 2 个端口，**一个数据端口和一个命令端口**（也叫做控制端口）。这两个端口一般是21 （命令端口）和 20 （数据端口）。控制 Socket 用来传送命令，数据 Socket 是用于传送数据。每一个 FTP 命令发送之后，FTP 服务器都会返回一个字符串，其中包括一个响应代码和一些说明信息。其中的返回码主要是用于判断命令是否被成功执行了。



## [TCP/IP协议](https://www.cnblogs.com/onepixel/p/7092302.html)

#### [TCP三次握手、四次挥手](<https://blog.csdn.net/qzcsu/article/details/72861891>)



#### [拥塞控制](https://www.cnblogs.com/myworld7/p/8385190.html)

拥塞控制是防止过多的数据注入到网络中，使网络中的路由器或链路不过载，这是一个**全局性**的。
流量控制是点对点的通信量的控制，是**端到端**问题。

发生拥塞的两种情况

- 超时
  出现超时，ssthresh = 1/2 cwnd，cwnd被置为1个MSS，然后开始慢启动
- 收到三个冗余ACK（窗口满了，多余的包丢掉）
  TCP对于这种丢包事件，较与超时的做出的反应，比较温和。TCP将cwnd减半（为使测量结果较好，计已收到的3个冗余ACK要加上3个MSS），并将ssthresh置为cwnd（未减半）的一半。然后进入快速恢复状态。



#### [TCP如何保证可靠传输](https://www.jianshu.com/p/6aac4b2a9fd7)

TCP通过序列号、检验和、确认应答信号、重发控制、连接管理、窗口控制、流量控制、拥塞控制实现可靠性。

**TCP发送方如何确定它的发送速率？一些指导性原则回答这些问题：**

- **一个丢失的报文段意味着拥塞，因此当丢失报文段时应当降低TCP发送方的速率**。

- **对当前未确认的报文的确认到达时，能够增加发送方的速率**。
  确认报文的到达可以看做一些顺利的指示，指示发送方报文段被顺利地交付给接收方，网络中没有出现拥塞。因此，拥塞窗口长度可增加。

- **带宽探测**

  ACK报文隐含地指示了从源到目的地的路径上面没有出现拥塞，丢包事件则指示出现了拥塞。由此，TCP便通过调节其传输速率增加影响ACK报文，如果出现丢包便减小传输速率，然后再进行增加速率，看拥塞状况是否改变。



#### [TCP（控制传输协议）和UDP（数据报协议）的区别](https://zhuanlan.zhihu.com/p/30499152)

1. 建立连接的方式有差异， TCP 是面向**连接的、可靠的、有序**的传输层协议，而 UDP 是**面向数据报的、不可靠的、无序**的传输协议，所以 UDP 压根不会建立什么连接。
2. 数据发送方式有差异，TCP理论上不存在限制，长数据会被截断成好几段，但UDP就是一份一份的数据报，有大小限制，具体受到协议，MTU，socket的UDP缓冲区大小限制。
3. 数据有序性的差异，TCP保证可靠传输，UDP不可靠、无序
4. 可靠性差异



#### [TCP通信中的粘包问题](<https://www.cnblogs.com/bypp/p/7597668.html>)

**为什么TCP会出现粘包？**

首先要介绍下TCP协议，TCP是面向连接的传输层协议，它的目标是提供可靠的端到端，因此采用了一些措施来保证可靠，也带来了**额外的开销**，如果按包发送的话，每次都要进行校验，开销是很大的。（长连接的情况）为了较少额外的开销，TCP采用了合并优化（**Nagle算法**）进行优化，将多次间隔较小、数据量小的数据，合并成一个大的数据块，然后进行封包。

UDP则不会使用块的合并优化算法，由于UDP支持的是一对多的模式，所以接收端的skbuff(套接字缓冲区）采用了链式结构来记录每一个到达的UDP包，在每个UDP包中就有了消息头（消息来源地址，端口等信息），这样对于接收端来说，就容易进行区分处理了。所以UDP不会出现粘包问题。

**概念：保护消息边界和流**

保护消息边界，就是指传输协议把数据当作一条独立的消息在网上传输，接收端只能接收独立的消息。也就是说存在保护消息边界，接收端一次只能接收发送端发出的一个数据包。而面向流则是指无保护**消息保护边界**的，如果发送端连续发送数据，接收端有可能在一次接收动作中，会接收两个或者更多的数据包。

例如，我们连续发送三个数据包，大小分别是2k，4k ，8k,这三个数据包，都已经到达了接收端的网络堆栈中，如果使用**UDP**协议，不管我们使用多大的接收缓冲区去接收数据，我们必须有三次接收动作，才能够把所有的数据包接收完.而使用**TCP协议**，我们只要把接收的**缓冲区大小设置在14k以上**，我们就能够一次把所有的数据包接收下来，只需要有一次接收动作。

所以，TCP是面向数据流的协议，没有消息边界，可能一次收到的是多个数据包，而UDP是面向消息的，一次只有一个数据包。

**如何避免出现粘包？**

> 对于发送方粘包，TCP提供了立即传送数据的强制指令PUSH，TCP收到该操作指令后就立即发送出去，而不用等待发送缓冲区满，也就是说一个数据包发送一次。
>
> 对于接收方粘包，则可通过优化程序设计、精简接收进程工作量、提高接收进程优先级等措施，**使其及时接收数据**，从而尽量避免出现粘包现象；
>
> 还可以由接收方控制，将一包数据按结构字段，人为控制分多次接收，然后合并，通过这种手段来避免粘包。
>
> 上面这三个方法都不太好
>
> 一种比较周全的对策是：**接收方创建一预处理线程，对接收到的数据包进行预处理，将粘连的包分开。**

**如何处理呢**？

TCP粘包无保护消息边界的解决思路

(1)发送固定长度的消息

(2)**把消息的尺寸与消息一块发送**

(3)**使用特殊标记来区分消息间隔**

**[进行网络通讯的封包和拆包](https://www.cnblogs.com/wiessharling/p/4230878.html)**

> 对于基于TCP开发的通讯程序，有个很重要的问题需要解决，就是封包和拆包
>
> **封包**
>
> 封包就是给一段数据加上包头,这样一来数据包就分为包头和包体两部分内容了(以后讲过滤非法包时封包会加入"包尾"内容)。包头其实上是个大小固定的结构体，其中有个结构体成员变量表示包体的长度，这是个很重要的变量，其他的结构体成员可根据需要自己定义。**根据包头长度固定以及包头中含有包体长度**的变量就能正确的拆分出一个完整的数据包。
>
> **拆包**
>
> 对于拆包目前我最常用的是以下两种方式：
>
> （1）动态缓冲区暂存方式
>
> （2）利用底层的缓冲区来进行拆包
>
> read(fd, buff, buff_len)     这里可以指明接收长度，以此达到拆包的目的



#### 为什么要有TIME_WAIT:

主动关闭的那端最后经历的状态,一般为2MSL秒(1~4分钟).

两个原因:

1. 保证当最后一个ack丢失后, 能收到对端重传的fin包.
2. **保证ack包消失, 不会影响下一个连接.**（重传时间一般为几百毫秒,而延时的数量级可能为几十秒(MSL数量级),所以延迟到达的包可能是曾经的fin包或其他,如果是fin,会影响下一个连接.）



#### [建立TCP连接的各个系统调用](https://blog.csdn.net/qq_37964547/article/details/81429627)



#### 常用协议与端口

| 应用程序   | FTP   | TFTP | TELNET | SMTP | DNS  | HTTP | SSH  | MYSQL |
| ---------- | ----- | ---- | ------ | ---- | ---- | ---- | ---- | ----- |
| 熟知端口   | 21,20 | 69   | 23     | 25   | 53   | 80   | 22   | 3306  |
| 传输层协议 | TCP   | UDP  | TCP    | TCP  | UDP  | TCP  |      |       |



#### [NAT ------ 内网的主机如何通过路由器与外网的主机通信](https://www.cnblogs.com/god-of-death/p/8052641.html)



#### [应用层协议ICMP以及PING命令的实现](<https://blog.csdn.net/Shawei_/article/details/81843742>) 

ICMP（Internet Control Message Protocol）**Internet控制报文协议**。

它是TCP/IP协议簇的一个子协议，用于在IP主机、路由器之间传递控制消息。**控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。**

ICMP协议是一种面向无连接的协议，用于传输出错报告控制信息。ICMP是封装在IP数据报中的。



#### [子网掩码的作用和用法](https://blog.csdn.net/kongguguren/article/details/79427465)

子网掩码只有一个作用，就是将某个IP地址划分成[网络地址](https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80)和[主机地址](https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA%E5%9C%B0%E5%9D%80)两部分。



#### [网关的作用](<https://www.cnblogs.com/bhlsheji/p/4277107.html>)

网关是一种充当转换重任的计算机系统或设备。在使用不同的通信协议、数据格式或语言,甚至体系结构全然不同的两种系统之间，网关是一个翻译器。与网桥仅仅是简单地传达信息不同，网关对收到的信息要又一次打包，以适应目的系统的需求。同一时候，网关也能够提供过滤和安全功能。大多数网关执行在OSI 7层协议的顶层--应用层。

网关：多指路由器的IP地址                                                              网关实质上是一个网络通向其它网络的**IP地址**。




#### 服务器压力测试入门

[吞吐量（TPS）、QPS、并发数、响应时间（RT）概念](<https://www.cnblogs.com/data2value/p/6220859.html>)

[wrk压力测试](https://www.cnblogs.com/ycyzharry/p/8372168.html)

[select 和 epoll 的应用场景](https://blog.csdn.net/d_guco/article/details/53166722)：不那么大量的连接长期有效，用select比较好，例如游戏服务器



#### [抓包命令 tcpdump](https://www.cnblogs.com/pyng/p/9698723.html)



## 其他参考链接

[socket的概念和原理](<http://blog.sina.com.cn/s/blog_4a3946360102y3bx.html>)	

> 它是网络通信过程中端点的**抽象**表示，应用层通过传输层进行数据通信时，TCP和UDP会遇到同时为多个应用程序进程提供并发服务的问题。为了**区别不同的应用程序进程和连接**，许多计算机操作系统为应用程序与TCP／IP协议交互提供了称为套接字(Socket)的接口，区分不同应用程序进程间的网络通信和连接。
>
> **注意：send()发送后，只是把数据放到了TCP的缓冲区，但是客户端不一定收到了。**

[超出TCP连接端口数限制（MaxUserPort）引起的服务器问题](https://www.cnblogs.com/dudu/p/5237777.html)