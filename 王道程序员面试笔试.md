`int *p[10]` 指的指针数组 他是个数组 有10个元素 每个元素是`int*`类型
也就是指向int的指针 也就是存放10int指针变量
int (*p)[10] 指的数组指针 他是指针 指向一个含有10个元素的数组

## 2. 字符串

#### 2.3

 strlen strcmp strcat strcpy 

memcpy（void* dest，const void* src, size_t n） 拷贝n字节到内存地址dest

memset （void* s, int ch, size_t n）将s中的前n个字节用ch替换并返回s

#### 2.4

字符串包含问题：BF算法，[KMP算法](<https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html>)

字符串移位包含：AABCD ，CDAA

​                               == s1+s1 包含 s2， 或者指针对s1求模   k % s1.size() 

字符串转数字 ：“+345” -> 345   剑指OFFER上有，条件判定有点多

技巧-字母素数化 ：a-2，b-3，c-5

“today is friday！”逆转为“friday！ is today“：分两步，第一步整个字符串反转，然后对空格分隔的单词反转。

```c++
char *p = "abcdefgh";
p += 3;
cout << strlen(strcpy(p, "ABCD)) <<endl;          //运行出错，p的对象在文字常量区
```



## 3. 结构体、共用体、枚举

#### 3.1 结构体struct

结构体可以相互赋值，数组不可以。

对于C++来说，结构体和类唯一的区别是默认控制权限不同。

对于C语言来说，结构体只有public的功能

#### 3.2 共用体union

对于共用体不同成员赋值，将会对其他成员重写

**大端格式**   高字节存储在低地址

**小端格式**   低字节存储在低地址

#### 3.3 枚举

可以代替const，未赋值的在前面一个基础上+1， 第一个为0

#### 3.4 sizeof()

sizeof是单目运算符不是函数，sizeof发生在编译时刻，可以当作常量表达式，并且忽略其括号内的运算.

**函数、不确定类型的表达式以及位域成员**不能计算sizeof值

32位指针sizeof：4， 64位：8

##### struct空间计算：

数据对齐，liunx+gcc下double的话是4的倍数即可

空结构体为1

## 4. 运算符及优先级

赋值操作具有右结合性，当表达式含有多个赋值操作时，从右向左结合。

#### 4.2 自增自减运算符

以++为例，对于变量a，++a表示取a的地址，增加他的内容，然后把值放到寄存器。a++表示取a的地址，把它的值放入寄存器，然后增加它在内存的值

前置自增能用作左值表达式，后置自增只能用作右值表达式

自增自减结合方向从右向左

#### 4.4 位运算符

（n & （n-1））== 0 用于判断二进制表示是否只有一位为1



异或的多种用途：两个相同的数异或为0、异或可以交换两个变量的值、异或可以实现两个数的加法、

两个数平均值（x&y）+((x^y) >>1)

#### 4.5 基本类型转换

在**表达式计算**中，C++将bool、char、unsigned char、short、signed short都会自动转换为int型

基本类型指针之间不存在隐式转换，只能强制转换

## 5. C预处理器、作用域、static、const以及内存管理

#### 5.1

C++中，宏替换实现的符号常量功能由const、enum代替，带参数的宏替换可由模板内联函数代替。

把多个语句用括号{}括起来组成的一个语句称复合语句。 

#### 5.3 static

##### 1.static的作用：

1）对其他源文件隐藏

2）默认初始化为0（未初始化的全局变量也具备这一属性，这两变量都存储在BSS段）

3）保持局部变量的持久性（但作用域依旧是局部）

##### 2.类中static：

表示属于一个类而不是属于此类的任何特定对象的变量和函数

**静态数据成员**定义时要分配空间，所以不能在类声明中定义，必须在类定义体的外部定义。

在类定义体中对静态变量赋值是错误的，但是基本整型const static数据成员可以在类的定义体中初始化，该数据成员仍必须在类的定义体之外进行定义，只不过定义时，不需要再初始化。

**静态成员函数**由于不与任何对象相关联，因此他不具有this指针，因而它也无法访问属于类的非静态成员数据与非静态成员函数。

static成员不是任何对象的组成部分，所以static成员函数不能被声明为const（将成员函数声明为const承诺不会修改该函数所属的对象，而static成员函数不属于任何对象），也不能声明为虚函数、volatile

#### 5.4 const:

把一个对象转换成常量，必须定义时初始化

全局作用域声明的const常量是定义该对象的文件的局部变量。

const代替define：#define BUFSIZE 100                   const bufsize=100                        const int bufsize = 100

##### 修饰参数与返回值

const修饰返回值

const用来修饰函数的参数，若是函数中不修改成员变量，应该尽可能用const修饰它

##### const在类中的作用

在成员函数末尾声明改变this的类型为const

const数据成员必须在构造函数的成员**初始化列表中进行初始化**，当常量整型数据成员同时被声明为static时，可使用外部初始化。

#### 5.5 内存管理与释放

栈区、堆区、文字常量区、代码区、全局（静态）存储区

char* p2 = new char[10]，p2存在于栈中，指向堆上分配的内存。

文字常量区不允许修改

##### 内存管理

动态创建的const对象必须在创建时初始化 const int *pci = new const int（1024）

1）malloc与free是库函数，而new/delete是C++运算符

malloc原型：void* malloc（size_t size）；

**用malloc申请一块整数类型地址的内存（需要做强制类型转换，因为默认返回void*）：**

```c
int *p = (int *) malloc(sizeof(int) * length)；
```

2）new自动计算需要分配的空间，而malloc需要手工计算

3）new是类型安全的，而malloc不是

4）new调用 operator new分配足够的空间，并调用相关的构造函数，而malloc不能调用构造函数；delete调用析构函数，然后调用类operator delete，free不能调用析构。



example：静态局部变量

作用域：局部

生命周期：程序运行期间一直存在

内存分布：全局（静态）存储区

##### 内存池（memory pool）

内存池是一种内存分配方式，在使用之前，先申请分配一定数量、大小相等的内存块备用，当有新的内存需求时，就从池中分布一部分，不够的话再申请。优点是避免内存随便，使得分配效率提升。

##### 缓冲区溢出：

指向缓冲区内填充**数据位数超过了缓冲区本身的容量限制**，导致溢出数据覆盖在合法数据上的情况。造成缓冲区溢出的原因是程序中没有仔细检查用户输入的参数。例如下面的程序：

```C
void function(char *str){
    char buffer[16];
    strcpy(buffer, str);
}
```

## 6. 函数

给函数传递实参遵循变量初始化规则

##### 传递指针的引用

```C
void ptrswap(int *&p1, int *&p2){
    int *temp = p2;
    p2 = p1;
    p1 = temp;;
}
```

#### 6.2 内联函数

1.成员函数成为内联函数

2.普通函数成为内联函数

编译时，使用内联函数的地方不进行函数调用，而是使用函数体展开，类似宏替换。

#### 6.3 默认参数

```C
void fun(int a, int b, int c = 5);
```

##### 可变参数

```c
int printf(const char* format,...)
```

#### 6.4 函数重载

要求参数个数或者类型上不同，不能仅仅基于返回类型不同重载

#### 6.5 函数模板与泛型

泛型编程就是以独立于任何特定类型的方式编写代码

```c++
template <typename T> //T跟在class或者typename之后，这里class或者typename没有区别
```

模板函数的inline应该加在返回值之前

#### 6.6 函数的递归

递归的精髓在于能否将原始问题转换为属性相同、但规模较小的问题

需要1）递归表达式 ；2）边界条件

借助栈实现递归=》非递归



##### extern ”C“

告诉编译器该**函数**是用C编译器编译的，请用C的方式链接他们。

## 7. 1指针	

##### tpyedef :别名

在编译时才处理，有类型检查；而define 是简单的替换，在预编译时处理

```C++
typename string *pstring；
const pstring cstr；

//const pstirng指针所表达的真实类型：cstr是指向string类型的const指针，等价于
string *const cstr；
```

#### 1.3 void*指针

表明该指针与地址值有关，但是不清楚此地址上的对象的类型。支持的操作：

1）与另一个指针比较

2）向函数传递或从函数返回

3）给另一个void*指针赋值

#### 1.5函数指针

```C++
bool (*pf)(const string &, const string &);
typedef bool (*cmpFun)(const string &, const string &)
```

该定义表示cmpFun是一种指向函数的指针的名字，该类型为返回bool类型并带有两个const string引用形参的函数的指针。

引用函数名但又没有调用该函数时，函数名自动解释为指向函数的指针。

可以使用函数名对函数指针做初始化赋值，赋值0值常量表示不指向任何函数。
```C++
bool lengthCompare(const string&, const string&);
cmpFun pf1 = 0;
cmpFun pf2 = lengthCompare;
pf2 = pf1;
pf2("hi", "bye");
```

使用时不需要解引用操作符*

##### 函数指针形参

```C++
void useBigger(cosnt string&, const string&, bool(const string&, const string&));
void useBigger(cosnt string&, const string&, bool(*)(const string&, const string&));
```

##### 返回指向函数的指针

```c++
int (*ff(int)) (int *, int);

typedef int (*pf)(int *, int);
PF ff(int);
```

具有函数类型的形参所对应的实参将被自动转换为指向相应类型的函数指针，但是，返回时函数时不行（无法进行这种转换）。

##### 指向重载函数的指针

必须与重载函数的一个版本精确匹配

```c++
extern void ff(unsigned int);
extern void ff(vector<bool>);

void (*pf)(unsigned int ) = &ff;
```

### 7.2. 引用

本质上来讲，引用还是指针，但是指针时不能修改的

不能引用类型的引用！

如果返回动态分配的内存或者对象，必须使用指针，引用可能导致内存泄漏

**const 引用是指向const 对象的引用，当引用对象是const， 引用也必须是const**

引用可以作为类的数据成员：

1）不能直接在构造函数里初始化，**必须用到列表初始化。**

2）凡是有引用类型的数据成员，必须有构造函数。



## 8. 类

#### 类成员简介

在类内部定义的函数默认为内联(inline).

深复制：那些引用其他对象的变量将指向被复制过的新对象，而不是原有的那些被引用的对象。

浅复制：被复制的所有对象都含有与原来相同的值，其他对象的引用仍然指向原来的对象。

#### 2.4 构造函数与析构函数的调用顺序

派生类构造函数调用顺序：

1）完成对象所占整块内存的开辟，由系统在调用构造函数时完成。

2）调用基类的构造函数完成基类初始化

3）若派生类中含对象成员、const成员或引用成员，则必须在初始化表中完成初始化。

4）派生类构造函数执行

#### 2.5 操作符重载

当操作符为成员函数时，它的第一个操作数隐式绑定到this指针

不能重新定义new 和delete 表达式的行为，能够被重载的时全局函数operator new 和 operator delete

operator new 的特点：

1）只分配所要求的空间，不调用相关对象的构造函数

2）可以被重载

3）重载时，返回类型必须声明为void*

4）重载时第一个参数类型必须为表达式要求分配空间的大小（字节），类型size_t

5）重载时可以带其他参数



#### 3. 成员函数的覆盖、重载与隐藏

覆盖（虚函数）与重载的区别：

1）覆盖时子类与父类，重载时同一个类不同方法；

2）覆盖要求参数列表相同，重载要求参数列表不同；**覆盖要求返回类型相同**，重载不要求

3）覆盖关系中，调用方法体是根据对象的类型来决定的，重载根据实参与形参



隐藏是屏蔽基类的同名函数

1）两个函数参数相同，但是基类不是虚函数

2）两个函数**参数不同**，无论基类函数是否虚函数，都会被屏蔽

```C++
class A{
public:
    virtual void fun (int xp){
        cout << xp << endl;
    }
};

class B:public A{
public:
	void fun(char *xp){}            //隐藏    
}
```



## 9.面向对象编程

#### 1 继承

虚继承时，公共基类在对象模型中只有一份拷贝

##### 公有继承public：

区分清楚派生类的对象和派生类中的成员函数对基类的访问权限是不同的（protected）

##### 私有继承private：

私有继承时，基类的成员只能由派生类访问，无法往下继承。所有成员都成为派生类的private

##### 保护继承：

特点是所有公有成员都成为派生类的保护成员。

#### 1.2 转换二义性

c++允许把基类的对象指针/引用强制转换成派生类的对象指针/引用。 （但是直接赋值不可以）

一个指向基类的指针可用来指向该基类**公有派生类的任何对象**。

2>多基继承

3>菱形继承

含有两个基类

#### 1.3 转换构造函数

可以用调用单个实参来调用的构造函数定义从形参类型到该类类型的隐式转换

```C++
class A{
public:
    A(int = 0);   //转换构造函数
private:
    int real;
};

A a = 1；   //A a = A(1);隐式转换
```

#### 1.4 类型转换函数

```c++
class A{
public:
    A(int = 0);   //转换构造函数
    operator int();//类型转换函数
private:
    int real;
};

A a = 1；   //A a = A(1);隐式转换
int i = a；
```

注意：

1>必须是成员函数

2>不能指定返回类型，但是一定用return 返回一个目标类型变量

3>不能有参数

```c++
operator int(){
    return real;
}
```

#### 2 虚函数多态

多态性指同一个操作用于不同的目标就会产生不同的影响

函数重载与运算符重载属于静态多态，虚函数属于动态多态

#### 2.1 联编

C++编译器根据传递给函数的参数和函数名决定具体使用哪个函数，称为联编或者绑定。

重定义的格式：与基类的虚函数有相同的参数个数，参数类型，返回类型

**虚函数的访问：**

通过对象名来调用虚函数，采用的是静态联编。取决于定义对象名的类型。

使用指针访问虚函数时，编译器根据指针所指的对象类型决定要调用哪个函数（**动态联编**），而与指针本身的类型无关。

Q：哪些函数不能为虚函数？

A：普通函数、静态成员、构造、友元函数、（内联成员、赋值操作符）（可以但没有意义）

C++不支持友元函数的继承

构造函数和析构函数中的虚函数，调用的是为构造函数或虚构函数**自身类型**定义的版本。



#### 2.2 虚函数表指针（vptr）及虚基类表指针（bptr）

##### 1.虚函数表指针(vptr)

 每个**对象**被添加一个指针，指向相关的虚函数表。vptr的设定和重置由构造函数、析构函数和复制构造函数自动完成。

##### 2.含静态变量、虚函数的类的空间计算

静态成员不对大小产生影响

vptr大小4

##### 3. 虚函数表的实现

##### 4. 虚基类表指针(bptr)

在虚拟继承基类的子类中，子类会增加某种指针(bptr)，或者指向虚基类子对象，或者指向一个相关的表格；表格中存放的不是**虚基类子对象的地址**，就是其**偏移值**

#### 2.3 虚拟继承时构造函数的书写

B:A     C: A     D:B,C               从A直接虚拟派生(B,C)和间接派生(D)的类中，其构造函数的初始化列表**都要列出对虚基类A的构造函数的调用。**

#### 2.4纯虚函数

对一个类来说，如果只定义了protected型的构造函数而没有提供public构造函数，是另一种形式的抽象类。



#### 9.3 动态运行时类型识别与显示转换

##### typeid：

typeid操作符能够问一个表达式，你是什么类型？

只有当typeid的操作数是带虚函数的类类型的对象的时，才返回动态类型信息。测试指针（相对于指针指向的对象）返回指针的静态的、编译时类型。

##### 显示转换：

**reinterpret_cast**:

```C++
int *ip;
char *pc = (char*) ip;
char *pc = reinterpret_cast<char*>(ip);  //这两个一样
```

**const_cast**:

转换掉const性质（添加或删除）

**static_cast:**

编译器**隐式执行**的任何类型都可以，否则出错！

```c++
class base{};
class child:public base{};
base* b;
child* c;
c = static_cast<child*>(b);//正确，但是不安全
c = b//错误
```

**dynamic_cast**:

.dynamic_cast涉及运行时类型检查。**对没有定义虚函数的l类使用dynamic_cast编译错误**

.待转换的类型**只能是指针或者引用**

dynamic_cast主要用于类层次间的上行转换和下行转换。在上行转换时，和static_cast效果一样，下行转换时，dynamic_cast具有类型检查功能，比static_cast更安全。

## 10. 分治法、动态规划与贪心算法



## 11.链表

#### 1. 单链表

单链表的建立分为头插法和尾插法

**快慢指针**：利用快慢指针在有序链表中寻找中位数

#### 2. 双链表



## 12. 栈与队列

**栈的应用:中缀表达式与后缀表达式**

队列只能在一端插入，另一端删除



## 13.树

树中一个结点的子结点个数称为该结点的度，树中结点的最大度数称为树的度

#### 4.树的应用

##### 二叉排序树（查找树）

##### 平衡二叉树

左右子树高度差不超过1

**红黑树**：结点不是红色就是黑色|根节点黑色|结点红则子节点黑|任一结点到尾的路径，黑结点数目相同

##### 哈夫曼树



## 14.图

#### 14.3 图的应用

**深度优先搜索**类似于树的先序遍历

**广度优先搜索**类似于树的层序遍历

#### 14.5 图的基本应用

最小生成树

最短路径

拓扑排序



## 15 排序算法

#### 5.1排序算法的稳定性

所有简单排序都是稳定排序(o(n^2)), 选择排序除外，所有时间复杂度o(nlog2n)的排序都是不稳定排序，**归并排序除外。**希尔排序是不稳定，基数排序是稳定

#### 5.3空间复杂度

归并的空间复杂度最高 o(n), 其次是快排o(logn)，其余都是o(1)



## 16 查找

#### 1.概念

查找结构：

适合静态查找表的查找方法：顺序查找、折半查找、散列查找等，适合动态查找：二叉排序树的查找、散列查找

平均查找长度：一次查找的长度是指需要比较的关键码次数，平均就是所有取平均

#### 2.二分查找

二分查找的结构必须具有随机存储的特性，该查找法仅适合于线性表的顺序存储结构，**不适合链式存储结构**，且要求元素关键字**有序排序**。

#### 5.哈希表

##### [哈希处理冲突的方法：](https://www.cnblogs.com/westlife-11358/p/10038878.html)

1.链地址法(拉链法)： 把所有的冲突关键字存储在一个线性链表中，这个链表由其散列地址唯一标识。

2.开放地址法：是指可存放新表项的空闲地址，既它的同义词表项开放，又向它的非同义词表项开放。

（线性探测法，二次探测法，伪随机探测法）                          Hi = (H(key) + di)%m

**开放地址时不能随便删除元素，需要做删除标记，进行逻辑删除。**

副作用是多次删除后，实际上很多位置没用，需要定期维护。

3.再散列法

用另一个哈希函数计算一个地址

4.建立一个公共溢出区



#### 6 一致性哈希

用来处理分布式数据库问题



#### 7 海量数据处理

##### 分治——Hash映射：

使用hash(value)%n， n就是要分的块数，这样相同值的元素就被分到同一块，然后对每个块内排序，排完后再整体归并排序。

十亿整数（随机生成，可重复）中前K最大的数 ：

类似问题的解决方法思路：首先哈希将数据分成N个文件，然后对每个文件建立K个元素最小/大堆（根据要求来选择）。最后将文件中剩余的数插入堆中，并**维持K个元素的堆**。最后将N个堆中的元素合起来分析。可以采用归并的方式来合并。在归并的时候为了提高效率还需要建一个N个元素构成的最大堆，先用N个堆中的最大值填充这个堆，然后就是弹出最大值，指针后移的操作了。当然这种问题在现在的互联网技术中，一般就用**map-reduce框架**来做了。 

##### Bit-map：

**使用位数组表示某些元素是否存在**——4，7，2，5，3 -> 10111100

ex：2.5亿个整数中找只出现一次的整数，每个数分配2bit（00不存在，01出现一次，10多次），然后依次扫描。

扫描结束后查看bitmap，输出位01的整数。

##### Bloom Filter(布隆过滤器)

基本原理是位数组与Hash函数联合使用，布隆过滤器是一个包含**m位的位数组**，然后定义k个不同的Hash函数，**每个hash函数都可以将集合中的元素映射到位数组的某一位。**

插入一个元素时，k个hash函数可以将此元素对应k个位，这些位全部置1

查询一个元素时，使用k个hash得到k个位，所有点都是1，则存在

可能误判，位被别的元素置1，一般应用在能够容忍错误率的场合。

##### 倒排索引法

文档检索系统中常用
