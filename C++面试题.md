#### 1.[extern关键字作用](<https://www.cnblogs.com/YQ2014/p/9799407.html>)

**extern可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中**，提示编译器遇到此变量和函数时在其他模块中寻找其定义。

加上extern “C”后，会指示编译器将这部分代码按C语言进行编译，而不是C++的。这是因为C++支持函数重载，因此，**编译器在编译函数的过程中会将函数参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。**



#### [2.static关键字作用](<https://blog.csdn.net/shanghairuoxiao/article/details/72904292>)

静态变量、静态函数、静态成员函数<https://www.cnblogs.com/xiaoxiaoxiao136/p/9687738.html>

##### static的作用：

1）对其他源文件隐藏

2）默认初始化为0（**未初始化**的全局变量也具备这一属性，这两变量都存储在BSS段）

3）保持局部变量的持久性（但作用域依旧是局部）

**static变量在头文件中定义，包含了该头文件的所有源文件中都定义了这些变量，即该头文件被包含了多少次，这些变量就定义了多少次。**



##### 类中static：

表示属于一个类而不是属于此类的任何特定对象的变量和函数

**静态数据成员**定义时要分配空间，所以不能在类声明中定义，必须在类定义体的外部定义。

**在类定义体中对静态变量赋值是错误的，但是基本整型const static数据成员可以在类的定义体中初始化，该数据成员仍必须在类的定义体之外进行定义，只不过定义时，不需要再初始化。**

**静态成员函数**由于不与任何对象相关联，因此他不具有this指针，因而它也无法访问属于类的非静态成员数据与非静态成员函数。

static成员不是任何对象的组成部分，所以static成员函数不能被声明为const（将成员函数声明为const承诺不会修改该函数所属的对象，而static成员函数不属于任何对象），也不能声明为虚函数、volatile

[成员函数在内存中的存储模型](https://www.cnblogs.com/rednodel/p/9300729.html)



##### static静态变量什么时候初始化

全局变量、文件域的静态变量和类的静态成员变量在main执行之前的静态初始化过程中分配内存并初始化；局部静态变量（一般为函数内的静态变量）在第一次使用时分配内存并初始化。

- 全局范围中的对象：**构造函数在所有函数调用之前执行，在主函数执行完调用析构函数。**
- 局部自动对象：建立对象时调用构造函数，离开作用域时调用析构函数。
- 动态分配的对象：建立对象时调用构造函数，调用释放时调用析构函数。
- 静态局部变量对象：建立时调用一次构造函数，**主函数结束时调用析构函数。**



#### [3.volatile的作用](https://blog.csdn.net/zwz2011303359/article/details/81809203)

volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改。	

volatile修饰字段告诉gcc**不要对该类型的数据做优化处理**，**对它的访问都是对内存的访问**，而不是对寄存器的拷贝值的访问。 



#### [4.const的作用](https://www.cnblogs.com/lanjianhappy/p/7298427.html)

[参考链接：C++ define和const的区别](https://www.cnblogs.com/puheng/p/9575379.html)



#### [5.new与malloc区别](https://www.cnblogs.com/QG-whz/p/5140930.html)

[参考链接](https://www.cnblogs.com/tp-16b/p/8684298.html)

基础：

  *  malloc/free只是动态分配内存空间/释放空间。而new/delete除了分配空间还会调用构造函数和析构函数进行初始化与清理（清理成员）。
  *  它们都是动态管理内存的入口。
  *  malloc/free是C/C++标准库的函数，new/delete是C++操作符。
  *  malloc/free需要手动计算类型大小且返回值类型为void*，new/delete可**自动计算类型的大小**，返回对应类型的指针。
  *  malloc/free管理内存失败会返回0，new/delete等的方式管理内存失败会抛出异常。

关于new的细节：

- 编译器用相差的4个字节用来保存一个东西——**对象个数**，即A* p = new A[10] 中的‘10’。
- [new/delete的重载](https://www.cnblogs.com/zhaobinyouth/p/9551826.html)：改变的只是内存的分配方式（即new出来的对象分配不一定在堆中）。并且该函数默认为`static`。
- 使用默认的[placement new](https://blog.csdn.net/linuxheik/article/details/80449059)来构造对象，就会在我们指定的内存空间中构造对象（**复用**）。`void* operator new (std::size_t size, void* ptr) throw(); `

关于`malloc`实现与隐式空闲链表详解见CSAPP书p587



#### [6.C++多态性与虚函数表](https://blog.csdn.net/hackbuteer1/article/details/7475622)

a、编译时多态性：通过重载函数实现 

函数能不能根据返回值重载呢？不能，为了保持解析操作符或函数调用时，独立于上下文。再举个例子，函数只调用，不接收返回值，编译器完全无法区别该调用哪个函数。

b、运行时多态性：通过虚函数实现。 



#### [7.静态多态和动态多态](https://blog.csdn.net/u013630349/article/details/48009815)

静态多态是指通过模板技术或者函数重载技术实现的多态，其在编译器确定行为。

动态多态是指通过虚函数技术实现在运行期动态绑定的技术。



#### [8.虚函数表](https://blog.csdn.net/haoel/article/details/1948051/)

这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。

[虚函数知识参考链接](<https://blog.csdn.net/li1914309758/article/details/79916414>)



#### 9.虚函数表是针对类的还是针对对象的？同一个类的两个对象的虚函数表是怎么维护的？

编译器为每一个类维护一个虚函数表，每个对象的首地址保存着该虚函数表的指针，同一个类的不同对象实际上指向同一张虚函数表。



#### 10. Effective C++ 条款< 7, 8, 9 >

##### 为什么对于存在虚函数的类中析构函数要定义成虚函数？

 直接的讲，C++中基类采用virtual虚析构函数是**为了防止内存泄漏**。具体地说，如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。**假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定**，因而只会调用基类的析构函数，而不会调用派生类的析构函数。那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。所以，为了防止这种情况的发生，C++中基类的析构函数应采用virtual虚析构函数。

那构造函数为什么不能是虚函数呢？虚函数采用的是一种虚调用的办法，虚调用是一种可以在只有部分信息的情况下工作的机制，特别运行我们调用一个只知道接口而不知道其准确对象类型的函数。**但是如果要创建一个对象**（对象都没有构造怎么确定虚函数调用呢），**势必要知道对象的准确类型，因此构造函数不能为虚。**

##### 析构函数能抛出异常吗？

不能！

##### 构造函数和析构函数中能调用虚函数吗？

构造函数先构造基类，在基类构造期间，虚函数并不是虚函数



#### [11.指针和引用的区别](https://www.cnblogs.com/gxcdream/p/4805612.html)

本质：引用是别名，指针是地址，具体的：

①从现象上看，指针在运行时可以改变其所指向的值，而引用一旦和某个对象绑定后就不再改变。这句话可以理解为：指针可以被重新赋值以指向另一个不同的对象。但是引用则总是指向在初始化时被指定的对象，以后不能改变，但是指定的对象其内容可以改变。
②从内存分配上看，程序为指针变量分配内存区域，而不为引用分配内存区域，因为引用声明时必须初始化，从而指向一个已经存在的对象。引用不能指向空值。
注：[标准没有规定引用要不要占用内存，也没有规定引用具体要怎么实现，具体随编译器]( http://bbs.csdn.net/topics/320095541)
③ 从编译上看，**程序在编译时分别将指针和引用添加到符号表上，符号表上记录的是变量名及变量所对应地址。指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值。符号表生成后就不会再改**，因此指针可以改变指向的对象（指针变量中的值可以改），而引用对象不能改。这是使用指针不安全而使用引用安全的主要原因。从某种意义上来说引用可以被认为是不能改变的指针。
④不存在指向空值的引用这个事实，意味着使用引用的代码效率比使用指针的要高。因为在使用引用之前不需要测试它的合法性。相反，指针则应该总是被测试，防止其为空。
⑤理论上，对于指针的级数没有限制，但是引用只能是一级。如下：

```C++
int** p1;         // 合法。指向指针的指针
int*& p2;         // 合法。指向指针的引用
int&* p3;         // 非法。指向引用的指针是非法的
int&& p4;         // 非法。指向引用的引用是非法的      <- C11中现在是右值引用了
```

  注意上述读法是从左到右。

Tips：有一个规则可以很好的区分const是修饰指针，还是修饰指针指向的数据——画一条垂直穿过指针声明的星号（*），如果const出现在线的左边，指针指向的数据为常量；如果const出现在右边，指针本身为常量。而引用本身就是常量，即不可以改变指向。



#### [12.智能指针是怎么实现的？什么时候改变引用计数？](<https://www.cnblogs.com/xiehongfeng100/p/4645555.html>)

##### **shared_ptr:**

**构造函数中计数初始化为1；**
**拷贝构造函数中计数值加1；**
**赋值运算符中，左边的原对象引用计数减一，右边的对象引用计数加一；**
**析构函数中引用计数减一；**
**在赋值运算符和析构函数中，如果减一后为0，则调用delete释放对象。**

[关于shared_ptr的线程安全性](https://www.cnblogs.com/gqtcgq/p/7492772.html)：本身安全，所持有的类不一定安全



##### weak_ptr：

weak_ptr并不改变其所共享的shared_ptr实例的引用计数，那就可能存在weak_ptr指向的对象被释放掉这种情况。这时，我们就不能使用weak_ptr直接访问对象。那么我们如何判断weak_ptr指向对象是否存在呢？C++中提供了lock函数来实现该功能。如果对象存在，lock()函数返回一个指向共享对象的shared_ptr，否则返回一个空shared_ptr(null)。

weak_ptr并没有重载operator->和operator *操作符，因此**不可直接通过weak_ptr使用对象**，典型的用法是调用其lock函数来获得shared_ptr示例，进而访问原始对象。



##### **unique_ptr:**

unique_ptr单独持有它所指向的对象，没有拷贝构造、赋值运算符，表明独占的思想，只能通过`release\reset`来进行对象的改变。



#### [13. C++四种类型转换](<https://www.cnblogs.com/xuelisheng/p/9327834.html>)

static_cast, dynamic_cast, const_cast, reinterpret_cast

使用dynamic_cast进行转换的，基类中一定要有虚函数，而且只能对指针或者引用操作，否则编译不通过。

关于[上下行转换](https://blog.csdn.net/fyyyr/article/details/79217808)



#### [14. C++内存对齐](https://www.cnblogs.com/zrtqsk/p/4371773.html)  32和64有区别的：指针、long

char:1 short:2 int:4 float:4 

long:(32:4/64:8) 

void*:(32:4/64:8) 

double:8 

long long: 8



#### 15.  内联函数

详见《Effective C++》 条款33



#### [16. C++内存管理](https://www.cnblogs.com/lyl-312/p/5528892.html)？内存池的作用？[STL里内存池如何实现？](https://www.cnblogs.com/nzhl/p/5753728.html)

**1.内存分配方式**

**在C/C++中内存分区**：栈区、堆区、(自由存储区、)全局/静态存储区和常量存储区

- 栈区

  - 通常是局部变量和函数参数，由编译器自动分配释放

- 堆区

  - 本来在我的理解中，动态分配的内存都应该在堆区，即new和malloc的内存都在此，现在才发现是把C和C++的记混了
  - C++中使用malloc分配的内存，在堆区，而由new分配的内存，则在**自由存储区**
  - 关于自由存储区和堆区的概念相关，见[C++ 自由存储区是否等价于堆？](http://www.linuxidc.com/Linux/2015-12/126520.htm)， 感谢小伙伴suilin的提醒。

- 自由存储区

  - C++中，由new分配的内存，在这个区。
  - 而在C语言中是没有这个区的，由malloc分配的内存，在堆区

- 全局/静态存储区

  - 全局变量和静态变量。
  - 在C语言中，全局变量又分为初始化的和未初始化的，其中初始化的全局变量和静态变量在这一分区，未初始化的全局变化和静态变量在与之相邻的另一区域中(BSS段)
  - 在C++中，没有区分变量的初始化和未初始化，所以，都在这一内存区

- 常量存储区

  - 存放（）常量的区域，不允许修改

  ```C++
  int a = 0; 全局初始化区 data
  char *p1; 全局未初始化区 bss
  main() 
  { 
  int b; 栈 
  char s[] = "abc"; 栈 
  char *p2; 栈 
  char *p3 = "123456"; "123456\0"在常量区，p3在栈上。 
  static int c =0； 全局（静态）初始化区 
  p1 = (char *)malloc(10); 
  p2 = (char *)malloc(20); 
  分配得来得10和20字节的区域就在堆区。 
  strcpy(p1, "123456"); "123456\0"放在常量区，编译器可能会将它与p3所指向的"123456"
  优化成一个地方。 
  } 
  ```

[成员变量存储在哪个区呢？](https://segmentfault.com/q/1010000004149330)那成员函数呢？



**2.分配很多小块的内存时，会造成很多的内存碎片，大大降低了内存的使用效率。为了减少内存碎片的出现，采用了内存池技术。**

STL内存池的思路其实是这样的:

1. 使用allocate向内存池请求**size大小**的内存空间, 如果需要请求的内存大小大于128bytes, 直接使用malloc.
2. 如果需要的内存大小小于128bytes, allocate根据size找到最适合的自由链表.

　　a. 如果链表不为空, 返回第一个node, 链表头改为第二个node.

　　b. 如果链表为空, 使用blockAlloc请求分配node.

　　　　x. 如果内存池中有大于一个node的空间, 分配尽可能多的node(但是最多20个), 将一个node返回, 其他的node添加到链表中.

　　　　y. 如果内存池只有一个node的空间, 直接返回给用户.

　　　　z. 若果如果连一个node都没有, 再次向操作系统请求分配内存.

　　　　　　①分配成功, 再次进行b过程

　　　　　　②分配失败, 循环各个自由链表, 寻找空间

　　　　　　　　I. 找到空间, 再次进行过程b

　　　　　　　　II. 找不到空间, 抛出异常(代码中并未给出, 只是给出了注释)

3. 用户调用deallocate释放内存空间, 如果要求释放的内存空间大于128bytes, 直接调用free.否则按照其大小找到合适的自由链表, 并将其插入.



#### 17. STL里set和map是基于什么实现的。红黑树的特点？

详见《STL源码剖析》

[STL中vector，Map，Set的实现原理](https://www.cnblogs.com/jijiji/p/4861651.html)

[红黑树的特点](https://www.cnblogs.com/woniu4/p/8086707.html)

[STL vector的内部实现原理及基本用法](<https://blog.csdn.net/u012658346/article/details/50725933>)



#### 18. [模板特化](https://blog.csdn.net/thefutureisour/article/details/7964682/)



#### [19. 定位内存泄露](https://www.cnblogs.com/skynet/archive/2011/02/20/1959162.html)（malloc/new的次数比free/delete的数量多）

(1)在windows平台下通过CRT中的库函数进行检测； 
(2)在可能泄漏的调用前后生成块的快照，比较前后的状态，定位泄漏的位置 
(3)Linux下通过工具**valgrind**检测



#### [20.钻石问题（菱形继承问题） 和虚继承](<https://www.cnblogs.com/sddai/p/6516668.html>)

详见 《C++对象模型》，[参考链接](https://blog.csdn.net/darmao/article/details/81454306)

![img](https://images0.cnblogs.com/blog/405877/201301/14092209-699710563dfe48c7aa33a94a5597b806.jpg)



#### [21.模板的全特化与偏特化](https://blog.csdn.net/thefutureisour/article/details/7964682/)

注意：**函数不能偏特化**，似乎不是因为语言实现不了，而是因为偏特化的功能可以通过函数的重载完成。



#### 22.private继承（见effective 39）

private并不是一个好选择，它代表着派生类根据基类来实现，通常情况下不如**复合**。如果派生类private了一个基类，编译器通常就**不会将一个派生类对象转换为一个基类对象**（public继承就会）。基类中的所有成员，在派生类中都会称为private属性。



#### 23.为什么要内存对齐

进行内存对齐的作用主要是有两个：
**（1）平台移植。不是所有的硬件平台都能够访问任意地址上的数据，**
**（2）性能：内存对齐后访问速度提升了。**
下面解释一下为什么内存对齐会提升效率。

CPU把内存当成是一块一块的，块的大小可以是2、4、8、16字节等大小。CPU在读取内存的时候是一块一块读取的。块大小即memory access granularity：内存读取粒度。

假设CPU要读取一个int型4字节大小的数据，看下列2种情况：
（1）数据从0字节开始；
（2）数据从1字节开始；
假设内存读取粒度是4.

![请输入图片描述](http://www.dewen.net.cn/upload/editor/15075036/201209201900016842.jpg?num=0.5047928770982804)

情况（1）的时候，CPU只需一次便可把4字节读取出来。
但是情况（2）的时候，要复杂一些。这个时候CPU先访问一次内存，读取0-3字节进寄存器，再读取4-7字节进寄存器，然后把0、6、7、8字节的数据删除掉，最后合并1-4字节的数据。可以看出，如果内存没有对齐，所进行的操作要复杂得多。

![请输入图片描述](http://www.dewen.net.cn/upload/editor/15075036/201209201904102950.jpg?num=0.7322397660075579)

尤其是，上面的这些操作也只是一部分CPU可以实现，即平台移植~~



#### 23.成员变量的初始化顺序

变量的初始化顺序：

① 基类的静态变量或全局变量     	②派生类的静态变量或全局变量

③基类的成员变量		④派生类的成员变量

注意：

①成员变量在使用初始化列表初始化时，与构造函数中初始化成员列表的顺序无关，只与定义成员变量的顺序有关。

②如果不使用初始化列表初始化，在构造函数内初始化时，此时与成员变量在构造函数中的位置有关。

③类中const成员常量必须在构造函数初始化列表中初始化。

④类中static成员变量，必须在类外初始化。



#### [24.C++中的静态绑定和动态绑定](<https://www.cnblogs.com/lizhenghn/p/3657717.html>)

- 静态绑定发生在编译期，动态绑定发生在运行期；
- 对象的动态类型可以更改，但是静态类型无法更改；

- 要想实现动态，必须使用动态绑定；

- **在继承体系中只有虚函数使用的是动态绑定**，其他的全部是静态绑定；



#### [25.C++中结构体与类的区别(struct与class区别)](https://www.cnblogs.com/starfire86/p/5367740.html)

**核心思想：struct更适合看成是一个数据结构的实现体，class更适合看成是一个对象的实现体。**

本质区别：

- 默认的访问控制，默认的继承访问权限struct是public的，class是private的。
- “class”这个关键字还用于定义模板参数，就像“typename”。但关键字“struct”不用于定义模板参数。​

默认的继承访问权限，struct是public的，class是private的，它们可以互相继承，默认是public继承还是private继承，**取决于子类**而不是基类。



#### [26.main函数执行之前都干啥了----C/C++运行时库剖析](https://www.cnblogs.com/yueqian-scut/p/3952263.html)

任何一个C/C++程序，它的背后都有一套庞大的代码来进行支撑，以使得该程序能够正常运行。这套代码至少包括入口函数，及其依赖的函数所构成的函数集合。当然，它还应该包括各种标准函数（如字符串，数学运算等）的实现。一般的程序运行过程如下：

1. 操作系统创建进程后，把控制权交给程序的入口函数`（gcc –e (_startEntryPoint)`, 这个函数往往是运行时库的某个入口函数。glibc 的入口函数是`_start`, msvc(vc6.0)是`mainCRTStartup`
2. 入口函数对运行库和程序运行环境进行初始化，**包括堆，I/O，线程，全局变量构造（constructor）等。**

3. 调用MAIN函数，正式开始执行程序主体。

4. 执行MAIN完毕，返回入口函数，进行清理工作，包括全局变量析构，堆销毁，关闭I/O等，然后进行系统调用介绍进程




#### [27.array和vector，数组三者区别和联系](<https://blog.csdn.net/alidada_blog/article/details/83029438>)



#### 28.右值、右值引用、类型推断、移动语义、完美转发

[从4行代码看右值引用](https://www.cnblogs.com/qicosmos/p/4283455.html)

[右值引用的作用](https://www.zhihu.com/question/22111546/answer/30801982?hb_wx_block=1&utm_source=wechat_session&utm_medium=social&utm_oi=817369688198746112)

> - 通过右值引用的声明，右值又“重获新生”，其生命周期与右值引用类型变量的生命周期一样长，只要该变量还活着，该右值临时量将会一直存活下去。让我们通过一个简单的例子来看看右值的生命周期。
> - 右值引用独立于左值和右值。意思是右值引用类型的变量可能是左值也可能是右值。 ？
> - T&& t在**发生自动类型推断**的时候，它是**未定的引用类型**（universal references），如果被一个左值初始化，它就是一个左值；如果它被一个右值初始化，它就是一个右值，它是左值还是右值取决于它的初始化。
>
> **引用折叠**规则：
>
> - 所有的右值引用叠加到右值引用上仍然还是一个右值引用；
> - 所有的其他引用类型之间的叠加都将变成左值引用。



#### [29.GDB调试]()

g++ -g 调试   

>  bt 查看函数堆栈情况
>
> print i 查看变量i的值
>
> whatis i 查看变量i的类型
>
> info b 查看



#### 30.RAII

**RAII**的核心思想是将资源或者状态**与对象的生命周期绑定**，通过C++的语言机制，实现资源和状态的安全管理。理解和使用RAII能使软件设计更清晰，代码更健壮。



## 其他参考资料

[C++锁的管理-- std::lock_guard和std::unique_lock](<https://blog.csdn.net/y396397735/article/details/81024755>)

[C++条件变量--std::condition_variable](https://blog.csdn.net/y396397735/article/details/81272752)

[C++11新特性之十：enable_shared_from_this](https://blog.csdn.net/caoshangpa/article/details/79392878)

[C++闭包的理解](https://www.jianshu.com/p/1eff5972c0f3) 闭包就是带有上下文的函数

[vector为什么要2倍增长，而不是固定值增长：科学证明，平均o(1)复杂度，](https://blog.csdn.net/dengheCSDN/article/details/78985684) VS为1.5倍，可以内存复用

[auto关键字](https://www.cnblogs.com/QG-whz/p/4951177.html)

[mutable关键字](https://www.cnblogs.com/yongdaimi/p/9565996.html)

[std::any(C17)](https://zh.cppreference.com/w/cpp/utility/any)

[**C++左值、左值引用、右值、右值引用、移动语义、完美转发**](<https://www.cnblogs.com/qicosmos/p/4283455.html>)

[C++中，编译器会为空类提供哪些默认成员函数？](<https://blog.csdn.net/leikun153/article/details/81840814>) 编译器会生成6个成员函数：一个缺省的构造函数、一个拷贝构造函数、一个析构函数、一个赋值运算符、两个取址运算符。

[C++中的原子操作](https://www.cnblogs.com/the-tops/p/6347584.html?utm_source=itdadao&utm_medium=referral)

[C++ std::thread](https://segmentfault.com/a/1190000002655852) 线程