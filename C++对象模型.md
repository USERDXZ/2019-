# 第三章 DATA语意学

```C++
//测试环境为VS2019
class Base {};                            //sizeof 1

class X :public virtual Base {};          //sizeof 4

class Y :public virtual Base {};          //sizeof 4

class A :public X, public Y {};           //sizeof 8
```

这里A的成员为一个X的虚表指针`vbptr`，一个Y的虚表指针，基类Base的1字节被编译器优化掉了。

如何理解静态成员？静态成员为整个类感兴趣的数据，非静态成员为个别类对象感兴趣的数据。

## DATA 成员绑定

`typedef`声明总应该放在类的起始位置！如果在声明之前，某个成员函数的参数使用了`typedef`的类型，编译器会向上查找是否存在，不存在就报错。

## DATA 成员布局

**静态成员变量**放在内存的**.data段**

非静态成员的排列需要符合**“较晚出现的成员在类对象中有较高的地址”**，但是它们不一定是连续的，例如内存对齐就会导致中间出现隔断。

虚指针则可以放在头或者尾部，举例：

```C++
class Base {
	int base;
};

class X :public virtual Base {
	virtual void print() { cout << " "; }
};

class Y :public virtual Base {};

class A :public X, public Y {
public:
	int a;
};
```

类A的成员布局如下(VS2019中)，前面的数据代表偏移量       (命令行/d1 reportAllClassLayout 查看模型)

```C++
class A	size(20):
	+---
 0	| +--- (base class X)
 0	| | {vfptr}
 4	| | {vbptr}
	| +---
 8	| +--- (base class Y)
 8	| | {vbptr}
	| +---
12	| a
	+---
	+--- (virtual base Base)
16	| base
	+---
```



## DATA 成员存取

static成员不论继承关系多复杂，都只有一个实例。

在成员函数中使用非static成员变量，会经由一个隐式的this指针来读取。

欲对一个非static成员变量进行存取，编译器需要把类对象的起始地址加上成员变量的**偏移地址(offset)**。

对比直接从对象存取和从指针指向对象存取（成员变量）的效率区别：指针指向的对象可能存在多态的情况，所以若存取的是**虚继承**来的**基类的成员变量**，会存在效率差异（要先通过虚表指针成员找到基类的位置）。其他情况效率都一样，因为所有**非static成员的偏移位置在编译器就确定了**。

## “继承”与DATA 成员

#### 单一继承

数据按照继承的先后顺序分布在类中。重点为C++保证继承的基类的成员完整性，**包括内存对齐的空间**。举例：

```C++
class C1 {                        //sizeof 8
public:
	int val;
	char a;
};

class C2 : public C1 {            //sizeof 12
	char b;
};

class C3 :public C2 {             //sizeof 16
	char c;
};

class C3	size(16):
	+---
 0	| +--- (base class C2)
 0	| | +--- (base class C1)
 0	| | | val
 4	| | | a
  	| | | <alignment member> (size=3)
	| | +---
 8	| | b
  	| | <alignment member> (size=3)
	| +---
12	| c
  	| <alignment member> (size=3)
	+---
```

#### 多态

带有虚函数的类

1. 类中多了一个**虚函数表**，存放虚函数的地址，**表的元素个数为虚函数的个数**，再加上一个或两个slots(?)
2. 每个类对象多一个虚指针`vfptr`，指向类的虚表，提供的是执行期的链接。
3. 构造函数增强，能够构建虚指针成员。（这可能意味着在基类和衍生类的构造中重新设定指针的值）
4. 析构函数增强，能够析构虚指针成员。

虚指针`vfptr`可以放在class尾也可以放在头，VS2019中是放在头的。放在头的好处是容易找到这个指针，不用记录它的偏移量，代价是丧失了和C语言的兼容性（因为头部多了一个隐形的指针变量）。

#### 多重继承

第一个出现（左边）的继承类在前，所有成员的位置（offset）在编译期就固定了，访问的时候不会有额外开销。

#### 虚继承

需要通过相关的指针来存取继承来的虚基类成员。

需要解决的问题：1.希望类对象有固定的复旦，不因其虚基类的个数而有所变化。	2.希望对基类成员的有固定的存取时间，不因为虚派生的深度而改变。

第一个问题解决办法：

- VS中是创建了**虚基类表**，再给每个对象安插一个**虚表指针**指向表，表中存放指向虚基类的指针。（我咋觉得也是存的偏移量呢？）
- 另外一种是在虚函数表中放置虚基类的偏移量，虚函数表正向为虚函数地址，负向就是索引到虚基类的偏移量。

第二个问题解决办法：拷贝所有虚基类的指针，放在派生类。

## 对象成员的效率

## 指向DATA 成员的指针

```C++
class A{
    int a;
};
& A::a;        //这个操作可以得到A中a的偏移量
```

如何区分一个没有指向任何成员变量的指针（空指针）和一个指向第一个成员变量的指针？为了进行区分，每个成员的**偏移量都被加上了1**。得到的值是一个不完整的值，它需要绑定到某个类对象的地址上才能使用。

```C++
int A::* p2 = &A::a;    //A::* 代表指向A成员的指针
std::cout << p2 << std::endl;     //输出1
```

如何通过指向成员的指针访问类对象的成员呢？

```C++
A* a = new A(5);
int A::* p2 = &A::a;
std::cout << c->*p2 << std::endl;         //注意*解引用，这里输出5
```



# 第四章 Function语意学

## 成员的各种调用方式

#### 非静态成员函数

成员函数会被内化为非成员函数，无任何额外消耗，会给一个额外的参数`this`指针。

编译器对这些内化的函数做了名称的特殊处理。

#### 虚成员函数

需成员函数内化：

```C++
ptr->normalize();      (*ptr->vptr[1])(ptr);
```

vptr指向虚函数表，1代表函数在表中索引位置，ptr表示this指针。（函数要用这个指针取数据）

> 如果显示，也就是指定调用哪个类的函数，会压制虚拟机制。
>
> 经由一个对象（而不是可能产生多态的指针）调用虚函数，编译器应该将这种操作和调用普通函数一样对待

#### 静态成员函数

主要特性就是没有this指针

1. 它不能够直接存取类中的非静态成员
2. 它不能够被声明为const、volatile或者virtual
3. 它不需要经由类对象才被调用

静态成员函数适合作为callback函数



## 虚拟成员函数

C++中多态表示以一个公有基类指针或者引用，寻址出一个派生类对象的意思。

**一个class只会有一个虚函数表**，每个表中有该类对象中所有的可用的**虚函数的实例的地址**，这组地址可在编译期获知，是固定不变的。这些函数包括：

- 类自己定义的函数实例，可能会覆盖基类的虚函数
- 继承的基类的未改写的虚函数
- 纯虚函数实例，意外调用可能结束函数

当通过指针调用虚函数时，我们不知道指针所指的对象时什么类型，但知道可以通过它包含的虚指针找到该对象的虚函数表，我们不知道哪个版本的虚函数会被调用，但是知道虚函数被放在表中的索引。

#### 多重继承下的虚函数：

这种情况复杂在第二个以及后继的基类上，“必须在**执行期调整this指针**”。

举例如下类，V3继承自两个有带有虚函数的类。

```C++
class V1 {
	int a;
public:
	virtual ~V1() {};
	virtual void v1(int _a) { a = _a; }
	virtual void print() { cout << "first" << endl; }
};

class V2 {
	int b;
public:
	virtual ~V2() {};
	virtual void v2(int _b) { b = _b; }
	virtual void print() { cout << "second" << endl; }
};

class V3 :public V1, public V2 {
	int c;
public:
	virtual ~V3() {};
	virtual void print() { cout << "third" << endl; }
};
```

当一个V2指针指向一个V3对象，` V2 *P2 = new V3;` 

这种情况，V2指针应该指向 类V2的成员在V3中的起始位置。当通过V2指针析构V3对象时，又应该将指针调整到对象的起始位置。并且这些**偏移量加法编译期是无法确定的**，因为V2指向的真正对象不确定。所以要解决的问题就是：编译器需要将**偏移量加到this指针的那一段代码**，插入到某个地方。

VS2019版本中 V3的成员布局 如下，可以看出虚函数表中记录了指针调整的操作。

```C++
class V3	size(20):
	+---
 0	| +--- (base class V1)
 0	| | {vfptr}
 4	| | a
	| +---
 8	| +--- (base class V2)
 8	| | {vfptr}
12	| | b
	| +---
16	| c
	+---
V3::$vftable@V1@:
	| &V3_meta
	|  0
 0	| &V3::{dtor}
 1	| &V1::v1
 2	| &V3::print
V3::$vftable@V2@:
	| -8                                  //偏移量offset
 0	| &thunk: this-=8; goto V3::{dtor}
 1	| &V2::v2
 2	| &thunk: this-=8; goto V3::print
```

**编译器会将多个虚函数表连锁为一个；指向次要表格的指针，可以由主要表格的名称加上一个offset获得。**

#### 虚继承下的虚函数

多了对象的this指针调整工作。有点复杂，举例如下，以及VS2019中对象的布局。

```C++

class p2d {
public:
	p2d(float _x = 0.0, float _y = 0.0):x(_x), y(_y){}
	virtual ~p2d() {};
	virtual void mumble() {};
protected:
	float x, y;
};

class p3d :public virtual p2d {
public:
	p3d(float _x = 0.0, float _y = 0.0, float _z = 0.0) : p2d(_x, _y), z(_z) {}
	virtual ~p3d() {}
	float getZ() { return z; }
protected:
	float z;
};

class p3d	size(20):
	+---
 0	| {vbptr}
 4	| z
	+---
	+--- (virtual base p2d)
 8	| {vfptr}
12	| x
16	| y
	+---
p3d::$vbtable@:
 0	| 0
 1	| 8 (p3dd(p3d+0)p2d)
p3d::$vftable@:
	| -8
 0	| &p3d::{dtor}
 1	| &p2d::mumble
```

#### 指向成员函数的指针

如果取非静态，非虚函数得地址，得到得是它在内存得真地址。

但是取虚函数得地址，只能得到一个索引值。



## Inline函数

**存取函数声明为inline，可以继续保持直接存取成员得那种高效性（原地展开），而且兼顾了函数得封装性。**

（实际执行时会在调用那个点上进行优化，对于可能产生重复求值得情况，会用临时变量保存）