# 第一部分 数据结构与对象

## 第二章 简单动态字符串SDS

```C
struct sdshdr{
    //已经使用的字节数量，不包含'\0‘
    int len;
    //未使用的
    int free;
    //字节数组
    char buf[];
}
```
SDS为了重用很多C函数库里面的函数，所以所有的SDS末尾默认补0，额外分配1字节也不进行记录。

优点：

1.  常数复杂度获取字符串长度
2. 杜绝缓冲区溢出 （修改前会进行检查）
3. 减少修改字符串长度时所需要的内存重新分配次数（不够时分配2倍需要的长度，例如len=13，free = 13）
4. 二进制安全（按二进制读取字节，不会对数据做任何限制、过滤，使用len长度而不是来'\0'判断是否结束）
5. 兼容部分C字符串函数



## 第三章 链表

无环双向链表，list存储信息，可设定修改幻术，listnode存储节点



## 第四章 字典

重点：渐进式哈希

#### 1.字典实现

哈希表，实现数据库和哈希键

```C
struct dictht{
    dictEntry **table;//数组，每个dictEntry保存键值对，包含next指针
    unsigned long size;//大小
    unsigned long sizemask;//大小掩码
    unsigned long used;//已用
}
```

通过dictEntry中的next指针解决冲突问题（开链法）

```C
typedef struct dictEntry{
    void *key;
    
    union{
        void *val;
        unit64_tu64;
        int64_ts64;
    } v;
    struct dictEntry *next;
}
```

字典

```c
typedef struct dict{
    dictType *type; //dictType保存了一簇用于操作特定类型键值对的函数
    void *privdata;//保存那些函数的可用参数
    dictht *ht[2];//两个哈希表，一般用0，rehash时用到1
    int rehashidx;//记录rehash进度，不在时为-1
}dict
```

#### 2.哈希算法

通过哈希算法计算哈希值，使用哈希值根据哈希表的sizemask掩码计算索引，算法：MurmurHash2

#### 3.解决键冲突

开链法

#### 4.rehash操作（重新散列）

发生情况：hash表保存太多或者太少键值对

步骤：

1. 为字典ht[1]哈希表分配空间，扩展操作——ht[1]的大小为第一个大于等于ht[0].used * 2的2^n；收缩操作——ht[1]的大小为第一个大于等于ht[0].used 的2^n
2. 重新计算哈希值和索引，放到ht[1]
3. 全放完后释放ht[0], ht[1]成为ht[0]，创建空白的ht[1]

扩展与收缩的条件：

服务器目前没有进行BGSAVE或者BGREWRITEAOF命令，并且哈希表负载大于等于1

服务器正在进行BGSAVE或者BGREWRITEAOF命令，并且哈希表负载大于等于5

当负载小于0.1，进行收缩

哈希表负载因子 = 哈希表保存的节点(used)数量/哈希表大小              （和STL一样）

#### 5.渐进式rehash

rehash动作不是一次性完成的，例如，如果存在千万上亿节点，那么一次性rehash，庞大的计算量会导致服务器停止服务。

rehash步骤（分而治之）：

1. 字典同时持有两个哈希表
2. 开始rehash时，变量`rehashidx`变为0，表示已经开始rehash操作
3. 在此期间，每次进行删除、添加、更新操作时，程序除了完成上述操作外，还对ht[0]上`rehashidx`索引上所有的键值对rehash到ht[1]，然后rehashidx加一
4. 随着3过程的不断进行，rehash全部完成后，rehashidx设为-1



## 第五章 跳跃表

平均 O(logN)、最坏O(N)复杂度的节点查找，通过顺序性操作来批量处理节点

用到的地点：实现有序集合键、在集群节点中用作内部数据

总结：

1. 跳跃表由zskiplist和zskiplistNode连个结构组成，前者用于存储信息，后者用于表示节点
2. 每个节点的层高为1-32之间的随机数
3. 在同一个跳跃表中，多个节点可以包含相同的分值，但是对象必须唯一



## 第六章 整数集合

当一个集合只**包含整数值元素，并且这个集合的元素数量不多时**，redis就会采用整数集合作为集合键的底层实现

```C
typedef struct intset{
    uint32_t enconding;   //编码方式:16, 32, 64
    uint32_t length;       //包含元素数量
    int8_t contents[];     //保存元素的数组，实际存储类型取决于编码方式
}int set;
```

当向一个底层为`int16_t`的数组添加`int64_t`类型的整数值时，会发生数组升级：扩展数组的空间大小，并为新元素分配空间，将原来的元素放在正确的位置，保持顺序不变，最后添加新元素。



## 第七章 压缩列表

**压缩列表是redis为了节约内存而开发的，是由一系列特殊编码的连续内存块促成的顺序型数据结构。**当一个列表键只**包含少量列表项**，并且每个列表项要么就是**小整数值**，要么就是长度**比较短的字符串**，那么redis就会用压缩列表来做表键的底层实现。

#### 1.压缩列表的构成

#### 2.压缩列表节点的构成

previous_entry_length：压缩列表中**前一个结点的长度。**

encoding：记录了结点的属性所保存的**数据类型以及数据长度**

content：保存的值，字节数组或者整数

#### 3.连锁更新

例如，原来的结点，记录前一个结点的长度得属性只要1个字节就能放下，现在插入了一个大于1个字节长度的结点，就要更新后面的结点，发生对后面多个结点 连锁的空间重新分配。



## 第八章 对象

redis不直接使用上述的数据结构，而是基于这些数据结构建立了**对象**系统——包含 字符串对象、列表对象、哈希对象、集合对象、有序集合对象。对象实现了引用计数、对象共享、LRU时间调度。

#### 1.对象类型与编码（编码也就是实现方式）

一个键值对由两个对象组成，一个对象是键（字符串对象），另一个是值，对象的结构如下：

```C
typedef struct redisObeject{
	unsigned type:4;          //表示对象的类型，也就是 是哪种对象？
    unsigned encoding:4;      //决定了底层是使用什么数据结构实现的（该对象）
    void* ptr;                //指向底层实现数据结构的指针
}robj;                        //例如，用跳跃表实现的有序集合
```

#### 2.字符串对象：int、raw和embstr

保存大于32字节的字符串：使用SDS, **编码为raw**。

保存小于32字节的字符串：使用embstr

embstr编码是用于保存短字符串的一种方式，使用的也是对象结构+SDS，但raw会调用两次内存分配函数来分别创建 `对象` 和 `sdshdr`，embstr则是一次内存分配函数来分配**一段连续的空间**，空间依次包含 `对象` 和 `sdshdr`。

注意：可以使用`long doubel`类型表示的浮点数在redis中也是作为字符串对象保存的。

转换：

1. 对int对象添加字符，int转raw
2. embstr只读，因此修改embstr时，会转raw

#### 3.列表对象：编码：ziplist（压缩列表）或者linkedlist（链表）

每个双端链表**节点**保存一个字符串对象

例如，我们有一个列表`robj`对象，`ptr`指针指向链表，**每个结点又都是一个字符串对象**，字符串用SDS实现

转换，列表满足以下条件使用压缩列表，否则使用链表：

- 所有字符串**元素长度小于64**
- 保存的元素数量小于512

#### 4.哈希对象：编码：ziplist（压缩列表）或者hashtabel（哈希表）

字典的每个键是一个字符串对象，值也是一个字符串对象

转换，列表满足以下条件使用压缩列表，否则使用哈希表：

- 所有字符串**元素长度小于64**
- 保存的元素数量小于512

#### 5.集合对象：编码：intset（整数集合）或者hashtabel

哈希表的键保存字符串对象，键为NULL

转换，满足下列条件用整数集合，否则哈希表：

- 集合对象保存所有元素都是整数
- 保存的元素不超过512个

#### 6.有序集合对象：ziplist或者skiplist（跳跃表）

ziplist：第一个节点保存元素的成员，第二个元素保存元素的分值，按分值从小到大排序

skiplist编码的**有序集合对象**使用zset作为底层实现，一个zset同时包含**一个字典和一个跳跃表。**

跳跃表节点保存一个集合元素：保存成员和分数，字典则创建了一个成员到分数的映射，完成`O(1)`复杂度查找指定成员的分数，字典和跳跃表使用指针来共享元素成员、分数，不会额外浪费空间

转换，满足下列条件使用ziplist，否则跳跃表：

- 有序集合保存的元素数量小于128
- 有序集合所保存的元素成员的长度都小于64

#### 7.类型检查与命令多态

redis两种类型命令：

1. 可以对任何键执行：DEL、EXPIRE、RENAME、TYPE等
2. 特定**对象**类型键执行

在执行2中的特定类型的键命令时，Redis检查输入对象的type属性。为了效率，Redis会根据对象的编码方式encoding属性，选择正确命令代码去执行。

#### 8.内存回收

对象有一个`refcount`属性，引用计数

引用计数+1：创建新对象、对象被新程序使用，不再使用-1，变0释放（类似智能指针）

#### 9.对象共享

使用指针，共享对象要进行比对是否相同，考虑到比对效率，Redis只对包含整数值的字符串对象进行共享，在初始化服务器时，创建了0~9999的所有整数值字符串对象。	

#### 10.对象空转时长

对象最后还包含一个`lru`属性，记录了对象最后对后一次被**命令程序**访问的时间。内存不够时，空转时间较长的会被回收。



# 第二部分 单机数据库的实现

## 第九章 数据库

这一章主要讲数据库的各种方法和功能，`redisDb`结构例，如添加、删除等操作的实现方法。

#### 1.服务器中的数据库

Redis有一个`redisServer`结构，保存着服务器的各种状态。里面有个db数组，保存着服务器，每一项都是一个`redisDb`，代表一个数据库。

```C
struct redisServer{
    redisDb* db;
    int dbnum;     //服务器数量，由配置决定
};
```

#### 2.切换数据库

每个客户端都有自己的目标数据库（要操作的数据库），用`SELECT`命令切换数据库。

在**服务器**中，对客户端也有一个`redisClient`结构，记录着客户端的各种状态。

```C
typedef struct redisClient{
    redisDb* db;     //指针，指向目标数据库
    
}redisClient;
```

#### 3.数据库键空间

Redis键值对数据库服务器，`redisDb`数据库结构用一个字典`dict`保存了**一个数据库中所有的键值对**，称为键空间，例如，保存一个列表键，键名——列表对象，保存一个哈希表键，键名——哈希表对象。

添加新键、删除键、更新键、对键取值，都是对键空间操作。

读与取时的维护操作：

- 读与写之后，根据键是否存在更新  命中次数或者不命中次数
- 读取后，更新一个键的LRU值
- 受WATCH监视的键，被读取后会被标记`dirty`，并且计数
- 如果服务器开启了通知，修改后还会，还会发送通知

#### 4.设置键的生存时间或过期时间

命令`EXPIRE`和`PEXPIRE`，对应秒或者毫秒，设定键的生存时间

命令`EXPIREAT`和`PEXPIREAT`，                       指定准确过期时间，这四个命令实际都转成最后一个执行

对应的，`PERSIST`可以移除一个键的过期时间



`redisDb`结构的有`expires`字典保存了数据库中所有键的过期时间，称为过期字典，这个字典中的**键是一个指针**，指向键空间中的某个键对象，**值是一个长整型整数**，保存了过期的时间。

程序通过这个过期字典，检查**给定键**是否存在；如果存在，那么取得键的过期时间。检查当前的UNIX时间戳是否大于过期时间，是的话过期。

#### 5.删除策略

三种删除方法，定时删除（主动，到期就删），惰性删除（调用的时候才删），定期删除（主动，一段时间删一次）。

定时删除：内存友好，CPU不友好，如果一定时间内有很多过期，就影响了服务器处理客户端的命令

惰性删除：CPU友好，内存不友好，惰性删除是下次取出过期键时才删除，那不取出就等于不删除（泄漏）

定时删除：介于上两者之间，通过限定删除操作的执行的时长和频率来减少对CPU的影响，也减少了内存浪费



#### 6.Redis的删除策略的实现

惰性：所有读写数据库的命令会调用一个检查过期的函数`expireIfNeeded`，然后判断是否删除

定期：在规定时间内，**分多次**遍历服务器的各个数据库，从数据库的**过期字典中随机检查一部分键**的过期时间，并删除过期键。                    （有一个全局变量记录遍历进度）



#### 7.RDB、AOF和复制功能对过期键的处理

RDB持久化功能（保存数据库数据到本地）、AOF持久化功能（保存生成当前数据库的命令到本地）

- RDB：创建新RDB文件时，会检查过期键，不会保存过期键
  ​	    载入RDB文件时，主服务器会检查过期键不载入，从服务器全部载入
- AOF：服务器以AOF持久化模式运行时，如果键过期，但是它**还没有被惰性删除或者定期删除**，那么AOF文件不会因为这个过期键而产生任何影响（因为，删除的操作都没执行啊），当过期键被删除，AOF文件就会追加一条DEL命令，显示的记录删除。               
  AOF重写过程中，程序会对数据库进行检查，已经过期的不会被保存到重写后的AOF文件中
- 复制：服务器运行下复制模式下，主服务器在删除后，会给从服务器发送DEL命令，告知删除。
  从服务器在执行客户端命令时，碰到过期键也像未过期一样处理，只有收到主服务器的DEL，才删除。
  保证主从服务器的数据一致性。



#### 8.数据库的通知功能

客户端通过订阅给定的频道或者模式，**来获知数据库中的变化，以及命令执行情况**。



## 第十章 RDB持久化

RDB持久化功能，将Redis在内存中的**数据库状态**保存到磁盘，RDB文件是一个**二进制文件**，通过该二进制文件可以还原生成RDB文件时的数据库状态。

重点：保存和载入RDB文件的方法，保存实现方法，自动保存原理

#### 1.RDB文件的创建与载入

`SAVE`阻塞Redis服务器进程，直到RDB文件创建完毕，`BGSAVE`非阻塞，派生一个子进程负责创建RDB文件。RDB文件的载入工作（阻塞）是在**服务器启动时自动执行**。启动时如果服务器开启了AOF持久化，会选择执行AOF。

`BGSAVE`执行期间，`BGREWRITEAOF`命令会被延后



#### 2.自动间隔性保存

可以配置服务器隔一段时间自动保存，设置多个保存条件，时间+操作次数，根据情况判断是否满足条件。



#### 3.RDB文件结构

od -c（ASCII） -x（16进制） 命令查看RDB文件



## 第十一章 AOF持久化

AOF持久化是通过保存Redis服务器所执行的命令来记录数据库状态，将服务器执行的`SET`、`SADD`、`RPUSH`三个命令保存到AOF文件中。服务器启动时，可以通过执行这些命令来还原数据库状态。

重点：AOF文件的写入、保存、载入等操作的实现，AOF重写

#### 1.AOF持久化实现

命令追加、文件写入、文件同步三个步骤

命令追加：服务器执行完一个写命令后，会以协议格式将执行的写命令追加到服务器状态的AOF缓冲区的末尾。

```C
struct redisServer{
    sds aof_buf;             //AOF缓冲区，为了提高写入效率，减少文件的写入次数
};
```

Redis的服务器就是一个事件循环（loop，reactor模式），里面处理各种事件、发送恢复等，每次结束一个循环前，都会调用`flushAppendOnlyFile`函数，考虑是否将缓冲区内容写入到文件，分几种写入方式（always、**everysec 操作由线程执行**、no）

#### 2.AOF文件的载入与数据还原

还原步骤：

1. 创建一个不带网络连接的**伪客户端**
2. 从AOF文件中分析并读取出一条命令
3. 使用伪客户端执行被读出的命令
4. 重复2-3

#### 3.AOF重写

因为是以被执行的写命令来记录服务器状态的，所以随着时间流逝，AOF文件内容会越来越多，并且有很多的冗余命令导致文件过大，读取还原也会浪费很多时间。

**重写功能，**通过该功能，Redis服务器可以创建一个新的AOF文件来替代现有的AOF文件，新旧文件的省掉了浪费空间的冗余命令，新旧文件保存的数据库状态相同，新AOF文件体积通常小得多。

**实现方法：**不要去读取和分析AOF文件，而是**直接从数据库中读取键list的值**，然后用一条一条的整命令来保存。首先从数据库中读键现在值，然后用一条命令去记录键值对。

注意：

作为一种维护手段，AOF重写程序放到**子进程**执行，不阻塞父进程，同时子进程有数据副本，保证数据安全。

在子进程执行期间，**服务器**多设置了一个**AOF重写缓冲区**，服务器处理新写命令后将命令发送给AOF缓冲区和AOF重写缓冲区，等待子进程完成AOF重写后，子进程向父发送一个信号，父进程收到后，调用一个信号处理函数，将AOF重写缓冲区的内容写入到新AOF文件，保证数据库一致性。



## 第十二章 事件

Redis是一个事件驱动程序，基于**Reacotr模式**开发了网络事件处理器，服务器需要处理两种事件：文件事件、时间事件。

#### 1.文件事件

Redis服务器通过套接字与客户端进行连接，文件事件就是服务器对套接字操作的抽象。

文件事件处理器使用**I/O多路复用程序**监听多个套接字，当监听的套接字准备好执行连接**应答(accept)、读取(read)、写入(write)、关闭(close)**等操作时，与操作对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前**关联好的事件处理器**来处理。

文件事件处理器：套接字、IO多路复用程序、文件事件派发器、事件处理器（Reactor网络库的设计模式）

注意：

多路复用通过包装常见的select、epoll、evport等实现

一个套接字又可读又可写的话，那么服务器先读后写



#### 2.时间事件

分定时事件、周期性事件，带有三个属性：id：全局唯一ID，when：毫秒级事件到达时间，timeProc：时间事件处理器（函数，也就是用啥函数处理事件）。

服务器将所有时间事件放在一个**无序链表**，每当时间事件执行器运行时，它就遍历链表，查找到达事件并调用相应的事件处理器



#### 3.事件的调度与执行

问题：何时处理，处理多久？

事件的调度和执行规则：

1. 循环（loop）中先阻塞等待文件事件产生，最大阻塞时间由到达时间**最接近当前时间的时间事件**决定
2. 文件事件是随机出现的，处理完一次文件事件后，未有任何时间事件到达，那么服务器将再次等待并处理文件事件
3. 对文件事件和时间时间的处理都是**同步、有序、原子**地执行的，服务器不会中途中断处理，也不会对事件进行抢占，因此，不管是文件事件的处理器，还是时间事件的处理器，都会尽可能减少程序的阻塞时间，并在有需要时主动让出执行权，从而降低造成事件饥饿的可能性。



## 第十三章 客户端

一个服务器可以与多个客户端建立网络连接。Redis服务器使用单线程单进程的方式处理请求，并与多个客户端进行网络通信，对于每个与服务器进行连接的客户端，服务器都为这些客户端建立了`redisClient`结构（客户端状态），保存了**客户端当前的状态信息**，以及执行**相关功能时需要的数据结构**。

Redis**服务器状态结构**有一个clients链表，保存了所有与服务器连接的客户端的状态结构


#### 1.客户端状态

- 套接字描述符：伪客户端为-1
- 名字：取名
- 标志：一部分标志记录了客户端的角色、部分记录了客户端所处的状态
- 输入缓冲区：用于保存客户端发送的命令请求
- 命令与命令参数：对输入缓冲区命令请i去进行解析，将得出的命令参数以及参数的个数分别保存argv、argc
- 命令的实现函数：根据上面argv[0]命令，取**命令表**中查找对应的命令实现函数，命令表是一个字典，保存了命令的名字，值是命令对应的`redisCommand`结构，结构保存了命令的实现函数、命令的标志、命令应该给定的参数个数、命令的总执行次数、总消耗时长等。查找到后，将客户端的cmd指向这个结构。
- 输出缓冲区：固定16k+可变缓冲区
- 身份验证：记录是否通过
- 时间：记录创建时间

#### 2.创建与关闭

创建普通客户端：加到服务器状态结构链表的末尾

关闭普通客户端：主动关闭，被KILL，超时，请求导致输入缓冲区超1GB，回复超出输出限制大小

Lua脚本的客户端

AOF文件的伪客户端



## 第十四章 服务器

#### 1.命令请求过程

1. 客户端发送命令请求SET KEY VALUE
2. 服务器就受并处理请求，在数据库结构中设置操作，并产生命令回复OK
3. 服务器将命令恢复发送给客户端
4. 客户端接收OK并打印回复

#### 2.serverCron函数

这个函数100ms执行一次，负责管理服务器资源，并保证服务器自身的良好运转

1. 更新服务器时间缓存（对服务器状态`redisServer`进行操作）
2. 更新Redis对象的LRU时钟
3. 更新服务器每秒执行命令的次数
4. 更新服务器内存峰值记录
5. 处理SIGTERM信号
6. 管理客户端资源：连接超时？缓冲区过大？
7. 管理数据库资源：对一部分数据库检查删除过期键
8. 执行被延迟的`BGREWRITEAOF`
9. 检查持久化操作的运行状态
10. 将AOF缓冲区内容写入AOF
11. 关闭输出缓冲区超限的客户端
12. 增加cronloops计数器的值：记录这个函数的执行次数

#### 3.初始化服务器

1. 初始化服务器状态结构：设置运行ID、默认运行频率、默认配置文件路径、运行架构、默认端口、设置默认RDB和AOF条件、初始化服务器的**LRU时钟**、创建**命令表**
2. 载入配置选项：用户通过给定配置参数或者指定配置文件可以修改默认配置，在这一步载入
3. 初始化服务器数据结构：**客户端链表，数据库数组，**频道订阅信息字典，Lua脚本环境，用于保存慢查询日志的属性，        为服务器设置进程信号处理器，**创建共享对象**，打开服务器监听端口，**为`serverCron`函数创建时间事件**，AOF持久化功能打开就**打开AOF文件或者创建新**的，初始化I/O模块
4. 还原数据库状态：**载入RDB或者AOF文件**
5. 开始执行事件循环（loop）

补充：加粗的都是前面详细题到过的部分



# 第三部分 多机数据库的实现

复制：让一个服务器去复制另一个服务器，构成主从服务器

Sentinel：哨兵，Redis高可用解决方案，用一个特殊的服务器去监控多个主服务器及所属的从服务器，当被监视的主服务器下线时，自动将某个从服务器升级为主服务器

集群：Redis提供的分布式数据库方案，通过分片来进行数据共享，并提供复制和故障转移功能

事务：通过MULTI EXEC WATCH实现，提供将多个命令打包，然后一次性、按顺序的执行多个命令，并且在事务处理期间，服务器不会中断事务去执行别的客户端的请求，以及Redis的ACID性质。
